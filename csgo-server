#! /bin/bash

####################### LICENSE AND COPYRIGHT INFORMATION ########################

info () { cat <<EOF; }
================================================================================

                           CS:GO Multi Server Manager
                           --------------------------

   Launch and set up your Counter-Strike: Global Offensive Dedicated Servers.
   Report bugs, get more information and receive updates to this script at:

                $(printf "\x1b[36;1m%s\x1b[m"               "https://github.com/dasisdormax/csgo-multiserver")

--------------------------------------------------------------------------------

        Copyright (C) 2016 Maximilian Wende <maximilian.wende@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");  you may not use
this  file except in compliance  with the License. You may obtain a  copy of the
License at:
                   $(printf "\x1b[36;1m%s\x1b[m"            "http://www.apache.org/licenses/LICENSE-2.0")

Unless required by applicable law or agreed to in writing,  software distributed
under  the License  is distributed on  an "AS IS"  BASIS,  WITHOUT WARRANTIES OR
CONDITIONS  OF ANY KIND,  either  express or  implied.  See the  License for the
specific language governing permissions and limitations under the License.

================================================================================

EOF




############################## USAGE OF THIS SCRIPT ##############################

usage () { cat <<EOF; }
Usage: $(bold "$THIS_COMM") < commands >

$(printf "\x1b[1;36m%s\x1b[m"              "GENERAL COMMANDS:")
    usage    > Display this help message
    info     > About this script / copyright and license information

$(printf "\x1b[1;36m%s\x1b[m"              "INSTANCE SELECTION:")
    @...     > Select the server instance to apply the following commands on.
             > If no name is given, work on the base installation instead.
    The default instance \$DEFAULT_INSTANCE can be specified in the config file

$(printf "\x1b[1;36m%s\x1b[m"              "INSTANCE-SPECIFIC COMMANDS:")
    create   > Create a new server instance
    start | stop | restart
             > Start/Stop/Restart given server instance (using tmux)
    status   > Check whether the server is currently running
    console  > Attach (connect) to the server's console. While inside, press
             > CTRL-D to detach (return to outside) without killing the server

$(printf "\x1b[1;36m%s\x1b[22m %s\x1b[m"   "ADMINISTRATION COMMANDS:" "(regarding the base installation)")
    admin-install
             > Configure this user as his own admin, install SteamCMD,
             > and optionally download the game
    update   > Install/Update the game server
    validate > Repair broken/missing game files

Commands will be executed in the order they are given. If a command fails,
subsequent commands will not be executed.

EOF





########################### BASIC SCRIPT CONFIGURATION ###########################

# Select user switch command (su or sudo)
# Note: `sudo -u USER command' would be greater, but takes more work
SU="sudo su -"
# SU="su -"

# APPID, APPNAME: Steam App ID an name of the game to be managed
APPID=740
APPNAME="csgo"

# SERVER_EXEC: The executable file of the server, within INSTANCE_DIR
SERVER_EXEC="srcds_run"

# MSM_CFG: General Configuration file location
# if a relative path is given, it is interpreted as relative to the user's home directory
MSM_CFG="$APPNAME-msm.conf"




################################ HELPER FUNCTIONS ################################

# A yes/no prompt. With the first parameter $1, an alternative prompt message can be given.
# returns true (0) for yes, and false (1) for no
prompt () {
	PROMPT="Proceed?"
	if [[ $1 ]]; then PROMPT="$1"; fi

	read -r -p "$PROMPT (Y/n) " INPUT
	# Implicit return value below
	[[ ! $INPUT || $INPUT =~ ^([Yy]|[Yy][Ee][Ss])$ ]]
}

# kills and deletes the tmux-session at location $SOCKET
delete-tmux () {
	tmux -S "$SOCKET" kill-server
	rm $SOCKET
	return 0
}

fix-permissions () {
	source "$SUBSCRIPT_DIR/permissions.sh" 2> /dev/null
	# Errors are ignored and expected, as not all accessed files are
	# necessarily ours, some files may not exist at all.
}

# Sets the instance to the value of $1
set-instance () {
	INSTANCE="$1"
	if [[ $INSTANCE ]];
	then
		INSTANCE_DIR="$HOME/$APPNAME@$INSTANCE"
		SERVER_TEXT="Server Instance @$INSTANCE"
	else
		INSTANCE_DIR="$INSTALL_DIR"
		SERVER_TEXT="Base Installation"
	fi
	SESSION_NAME="$USER@$INSTANCE"
	SOCKET="$INSTALL_DIR/msm.d/clients/$SESSION_NAME"
}

caterr  () { printf "\x1b[31m" 1>&2; cat 1>&2; printf "\x1b[m" 1>&2; }

catwarn () { printf "\x1b[33m" 1>&2; cat 1>&2; printf "\x1b[m" 1>&2; }

catinfo () { printf "\x1b[36m"     ; cat     ; printf "\x1b[m"     ; }

# Make text $1 bold
bold () { printf "\x1b[1m%s\x1b[22m" "$1"; }




########################## GENERAL SCRIPT CONFIGURATION ##########################

# Get absolute config file location, based on MSM_CFG
# $1 is the base directory, if omitted, the current home directory is taken
cfgfile () {
	if [[ $MSM_CFG =~ ^/ ]]; then
		local CFG="$MSM_CFG"
	else
		if [[ $1 ]]; then
			echo "$1/$MSM_CFG"
		else
			echo "$HOME/$MSM_CFG"
		fi
	fi
}

CFG=$(cfgfile)

# Check environment variables for correctness
# If an argument $1 is given, these variables are checked for that user instead of the current one
checkvars () {
	if [[ $1 ]]; then local USER="$1"; fi
	if [[ ! $ADMIN ]]; then
		caterr <<< "$(bold "ERROR:") ADMIN is not defined!"
		return 1
	fi
	if [[ $USER == $ADMIN && ( ! $STEAMCMD_DIR || ! -x $STEAMCMD_DIR/steamcmd.sh ) ]]; then
		caterr <<< "$(bold "ERROR:") STEAMCMD_DIR is not defined or steamcmd.sh was not found in it!"
		return 1
	fi
	if [[ ! $INSTALL_DIR ]]; then
		caterr <<< "$(bold "ERROR:") INSTALL_DIR is not defined!"
		return 1
	fi
	if [[ ! -r $INSTALL_DIR ]]; then
		caterr <<< "$(bold "ERROR:") $(bold "$INSTALL_DIR") does not exist or is not readable!"
		return 1
	fi
	if [[ $(cat "$INSTALL_DIR/msm.d/appid" 2> /dev/null) != $APPID || ! -d "$INSTALL_DIR/msm.d/clients" ]]; then
		caterr <<-EOF
			$(bold "ERROR:") The directory $(bold "$INSTALL_DIR")
			       is not a valid base installation for $APPNAME!
		EOF
		return 1
	fi
	return 0
}

# reads the user's configuration file or the file given with $1
readcfg () {
	if [[ $1 ]]; then local CFG="$1"; fi
	if [[ -r $CFG ]]; then
		source "$CFG" # this isn't great, as a config file of a different user can potentially be malicious
		checkvars || {
			caterr <<< "$(bold "ERROR:") One or more errors in the configuration file $(bold "$CFG")!"
			return 1
		}
		return 0
	fi
	caterr <<< "$(bold "ERROR:") Configuration file $(bold "$CFG") does not exist!"
	return 1
}

# prints the variable values for the config file
printcfg () {
	cat <<-EOF
		#! /bin/bash
		# This is a configuration file for CS:GO Multi Server Manager
		ADMIN="$ADMIN"
		INSTALL_DIR="$INSTALL_DIR"
		DEFAULT_INSTANCE="$DEFAULT_INSTANCE"
		EOF
	# Vars that are only interesting for the admin
	if [[ $USER == $ADMIN ]]; then cat <<-EOF
		STEAMCMD_DIR="$STEAMCMD_DIR"
		EOF
	fi
}

# Write configuration file for the current user
writecfg () {
	CFG=$(cfgfile)
	echo "Creating CS:GO MSM Config File in $(bold "$CFG") ..."
	checkvars || { echo; return 1; }

	rm $CFG > /dev/null 2>&1
	printcfg > $CFG
	echo
}




############################ SERVER CONTROL FUNCTIONS ############################

start () {
	echo "Starting $SERVER_TEXT ..."
	# Nothing to do if server is already running
	if status; then catinfo <<-EOF; return 0; fi
		$(bold "INFO:")  $SERVER_TEXT is already running!
		       Enter the console using \`$THIS_COMM @$INSTANCE console'

		EOF

	if [[ ! -d $INSTANCE_DIR ]]; then caterr <<-EOF; return 1; fi
		$(bold "ERROR:") Instance directory $(bold "$INSTANCE_DIR") does not exist!
		       Create an instance using \`$THIS_COMM @$INSTANCE create-instance'

		EOF

	if [[ ! -w $INSTANCE_DIR ]]; then caterr <<-EOF; return 1; fi
		$(bold "ERROR:") You do not have full access to $(bold "$INSTANCE_DIR")!
		       Only $(bold "$ADMIN") can modify and launch the base installation! Try creating
		       an own instance using \`$THIS_COMM @name create-instance' instead.

		EOF

	if [[ ! -x $INSTANCE_DIR/$SERVER_EXEC ]]; then caterr <<-EOF; return 1; fi
		$(bold "ERROR:") Server Executable not found at $(bold "$INSTANCE_DIR/$SERVER_EXEC")!
		       Try repairing the installation using \`$THIS_COMM update',
		       \`$THIS_COMM repair' or re-create this instance.

		EOF

	# TODO: actual start procedure here

	echo
	echo "$SERVER_TEXT started successfully!"
	echo "To enter the game's console, type \`$THIS_COMM @$INSTANCE console'."
	echo
	return 0 # success
}

stop () {
	echo "Stopping $SERVER_TEXT ..."
	status || { echo; return 0; }

	# TODO: actual stop procedure here

	echo
}

# Status (Up/Down and extra info) of the server in tmux session $SESSION_NAME
status () {
	# Check if tmux socket exists and is accessible
	if [[ ! -e "$SOCKET" ]]; then
		return 1 # false - not running
	fi
	if [[ ! -w "$SOCKET" ]]; then caterr <<-EOF; return 23; fi # 23 = access error
		$(bold "ERROR:") Cannot access socket of session $(bold "$SESSION_NAME")!

		EOF

	if ( tmux -S "$SOCKET" has-session >/dev/null ); then
		# No session runs within tmux
		delete-tmux
		return 1 # false - not running
	fi

	# Get server pid and owner
	eval "local $(tmux -S "$SOCKET" showenv SERVER_PID)"
	local SOCKET_OWNER="$(ls -ld "$SOCKET" | awk 'NR==1 {print $3}')"
	if [[ ! $SERVER_PID ]]; then delete-tmux; fi

	# Check, if pid actually is the server and belongs to the user
	local PS_OUT="$(ps -o uname=,comm= -p "$SERVER_PID"  2>/dev/null)"
	if [[ $PS_OUT != "$SOCKET_OWNER $SERVER_EXEC" ]]; then
		delete-tmux
		return 1 # false - not running
	fi
	# Game Server found
	return 0
}

# Switch to the game console in tmux session
console () {
	if ! status; then caterr <<-EOF; return 1; fi
		$(bold "ERROR:") $SERVER_TEXT is not running

		EOF
}




########################### ADMIN MANAGEMENT FUNCTIONS ###########################

update () {
	local ACTION="update"
	if [[ $1 == "validate" ]]; then local ACTION="validate"; fi
	if [[ $USER != $ADMIN ]]; then
		catwarn <<-EOF
			Only the admin $(bold "$ADMIN") can $ACTION the base installation.
			Please log in to the account of $(bold "$ADMIN") now! (or CTRL-D to cancel)
			EOF
		$SU "$ADMIN" -c "'$THIS_SCRIPT' $ACTION"
		if (( $? )); then caterr <<-EOF; return 1; fi
			$(bold "ERROR:") Installation/update as $(bold "$ADMIN") failed!

			EOF
		return 0
	fi

	touch "$INSTALL_DIR/msm.d/updating"

	local LOGFILE="$STEAMCMD_DIR/$ACTION.log"
	echo > "$LOGFILE"
	catinfo <<< "$(bold "INFO:")  Log File: $(bold "$LOGFILE")"
	echo

	tries=5
	try=0
	unset SUCCESS
	until [[ $SUCCESS ]] || (( ++try > tries )); do
		tee -a "$LOGFILE" <<-EOF | catinfo
			####################################################
			# $(printf "[%2d/%2d] %40s" $try $tries "$(date)") #
			# $(printf "%-48s" "Trying to $ACTION the game using SteamCMD ...") #
			####################################################

			EOF
		$(which unbuffer) "$STEAMCMD_DIR/steamcmd.sh" +runscript "$STEAMCMD_DIR/$ACTION" | tee -a "$LOGFILE"
		echo >> "$LOGFILE" # an extra newline in the file because of the weird escape sequences that steam uses
		echo | tee -a "$LOGFILE"

		if ( egrep "Success! App '$APPID'.*(fully installed|up to date)" "$LOGFILE" > /dev/null ); then
			local SUCCESS=1
		fi
	done

	fix-permissions

	# Update timestamp on appid file, so clients know that files may have changed
	rm "$INSTALL_DIR/msm.d/updating"
	touch "$INSTALL_DIR/msm.d/appid"

	unset try tries
	if [[ $SUCCESS ]]; then
		catinfo <<< "$(bold "INFO:")  Update completed successfully!"
		echo
		return 0
	else catwarn <<-EOF; return 1; fi
		$(bold "WARN:")  Update failed! For more information, see the log file"
		       at $(bold "$LOGFILE")."

		EOF
}

delete-all-tmuxes () {
	local BASEPATH="$INSTALL_DIR/msm.d/clients"
	# Nothing to do, if the path does not exist
	if [[ ! -w $BASEPATH ]]; then return 0; fi

	for sock in $(ls "$BASEPATH"); do
		local SOCKET="$BASEPATH/$sock"
		if [[ -w $SOCKET ]]; then
			delete-tmux
		fi
	done
	unset sock
}




###################### SERVER INSTANCE MANAGEMENT FUNCTIONS ######################

# Checks existing data in INSTANCE_DIR, and prints appropriate warnings
# if data would have to be deleted
check-instance-dir () {
	[[ -e $INSTANCE_DIR ]] && {
		if ! [[ -d $INSTANCE_DIR ]]; then
			caterr <<-EOF
				$(bold "ERROR:") $(bold "$INSTANCE_DIR") is not a directory! Move the file and try again.

				EOF
			return 23
		fi

		if ! [[ -r $INSTANCE_DIR && -w $INSTANCE_DIR && -x $INSTANCE_DIR ]]; then
			caterr <<-EOF
				$(bold "ERROR:") You do not have the necessary privileges to create a server instance
				       in $(bold "$INSTANCE_DIR")!

				EOF
			return 23
		fi
		
		if [[ $(ls -A "$INSTANCE_DIR") && $(cat $INSTANCE_DIR/msm.d/appid 2> /dev/null) != $APPID ]]; then
			catwarn <<-EOF
				$(bold "WARN:")  The directory $(bold "$INSTANCE_DIR") already contains data,
				       which may or may not be game server data. Please backup any important
				       files before proceeding!

				EOF
			return 1
		fi

		if [[ $(ls -A "$INSTANCE_DIR") && ! -d $INSTANCE_DIR/msm.d/clients ]]; then
			catwarn <<-EOF
				$(bold "WARN:")  A game instance already exists at $(bold "$INSTANCE_DIR").
				       Please backup any important files before proceeding!

				EOF
			return 1
		fi
	}
	return 0
}

# recursively symlinks all files from the base installation that do not exist yet in the instance
symlink-all-files () {
	# Return if .donotlink file exists in target.
	# This file should be created by instance creation scripts
	if [[ -e $INSTANCE_DIR/$1.donotlink ]]; then return 0; fi
	# Loop through files in directory
	for file in $(ls -A "$INSTALL_DIR/$1"); do
		# MSM directory or already symlinked files do not need any more work
		if [[ -L $INSTANCE_DIR/$1$file || $file == msm.d ]]; then continue; fi
		# recurse through subdirectories
		if [[ -d $INSTANCE_DIR/$1$file ]]; then symlink-all-files "${1}${file}/"; continue; fi
		# Create symlink for nenexistent file
		if [[ ! -e $INSTANCE_DIR/$1$file ]]; then 
			ln -s "$INSTALL_DIR/$1$file" "$INSTANCE_DIR/$1$file"
			continue
		fi
	done
}

create-instance () {
	cat <<-EOF
		-------------------------------------------------------------------------------
		               CS:GO Multi-Mode Server Manager - Instance Setup
		-------------------------------------------------------------------------------
		EOF

	if [[ -d $INSTANCE_DIR/msm.d/clients ]]; then catinfo <<-EOF; return 0; fi
		$(bold "INFO:")  You have selected a base installation, There is no need to create an
		       instance here. If you want to create a new instance, set the instance
		       name using \`$THIS_COMM @name create'.

		EOF

	check-instance-dir
	local errno=$?
	if (( $errno == 1 )); then
		catwarn <<-EOF
			If you continue, ALL DATA in $(bold "$INSTANCE_DIR")
			WILL BE DELETED! You have been warned!

			EOF
		sleep 3
		prompt "Are you sure?" || { echo; return 1; }
		echo
	elif (( $errno )); then
		return 1
	fi

	############ INSTANCE CREATION STARTS NOW ############
	rm -rf "$INSTANCE_DIR" > /dev/null 2>&1

	mkdir -p "$INSTANCE_DIR/msm.d"

	# Execute Instance creation script. This will copy all files that the
	# instance owner should be able to modify himself.
	echo
	echo "Copying instance-specific files ..."

	source "$SUBSCRIPT_DIR/instance.sh"

	if (( $? )); then
		caterr <<-EOF
			$(bold "ERROR:") An error occured while executing the instance creation script!

			EOF
		rm -rf "$INSTANCE_DIR" > /dev/null 2>&1
		return 1
	fi

	echo
	echo "Linking remaining files to the base installation ..."

	echo "$INSTALL_DIR" > "$INSTANCE_DIR/msm.d/install-dir"

	if ! symlink-all-files; then
		caterr <<-EOF
			$(bold "ERROR:") Linking this instance to the base installation failed.

			EOF
		rm -rf "$INSTANCE_DIR" > /dev/null 2>&1
		return 1
	fi

	echo
	echo "Performing final steps ..."

	cp "$INSTALL_DIR/msm.d/appid" "$INSTANCE_DIR/msm.d/appid"
	cp "$INSTALL_DIR/msm.d/appname" "$INSTANCE_DIR/msm.d/appname"
	cp -R "$INSTALL_DIR/msm.d/modes" "$INSTANCE_DIR/msm.d/modes"
	cp "$SUBSCRIPT_DIR/server.conf" "$INSTANCE_DIR/msm.d/server.conf"
	
	fix-permissions

	echo
	echo "Instance created successfully in $(bold "$INSTANCE_DIR")!"
	echo
}




##################################### SETUP #####################################

setup () {
	# First-time setup
	cat <<-EOF
		-------------------------------------------------------------------------------
		                CS:GO Multi-Mode Server Manager - Initial Setup
		-------------------------------------------------------------------------------

		It seems like this is the first time you use this script on this machine.
		Before advancing, be aware of a few things:

		>>  A configuration file will be created in the location:
		        $(bold "$CFG")"

		    If you want to use a different location, exit and edit
		    the \$MSM_CFG variable within this file accordingly.

		>>  For multi-user setups, this script, located at
		        $(bold "$THIS_SCRIPT")
		    must be readable for all users.

		EOF
	if ! prompt; then echo; return 1; fi
	# Query steam installation admin user
	cat <<-EOF

		Please choose the user that is responsible for the game installation and
		updates on this machine. As long as the access rights are correctly set,
		this server will use the game data provided by that user, which makes
		re-downloading the game for multiple users unnecessary.

		EOF
	while [[ ! $ADMIN_HOME ]]; do
		read -p "Admin's username (default: $USER) " -r ADMIN
		if [[ ! $ADMIN ]]; then ADMIN="$USER"; fi
		if [[ ! $(getent passwd $ADMIN) ]]; then
			caterr <<< "$(bold "ERROR:") User $(bold "$ADMIN") does not exist! Please specify a different admin."
			echo
			continue
		fi
		ADMIN_HOME=$(eval echo "~$ADMIN")
		if [[ ! -r $ADMIN_HOME ]]; then
			caterr <<-EOF
				$(bold "ERROR:") That user's home directory $(bold "$ADMIN_HOME")
				       is not readable! Please specify a different admin.

				EOF
			ADMIN_HOME=
		fi
	done

	echo
	# Check if the admin has a working configuration already
	if [[ $USER != $ADMIN ]]; then
		# If client installation fails (e.g. the admin has no configuration himself,
		# try admin installation
		if ! client-install; then
			catwarn <<-EOF
				$(bold "WARN:")  Additional installation steps are required on the account of $(bold "$ADMIN")!
				       Please log in to the account of $(bold "$ADMIN") now!
				EOF

			$SU $ADMIN -c "\"$THIS_SCRIPT\" admin-install"

			if (( $? )); then caterr <<-EOF; return 1; fi
				$(bold "ERROR:") Admin Installation for $(bold "$ADMIN") failed!

				EOF

			# Try client installation again!
			if ! client-install; then caterr <<-EOF; return 1; fi
				$(bold "ERROR:") Client Installation failed!

				EOF
		fi
	else
		admin-install
	fi
}

client-install () {
	echo "Trying to import settings from $(bold "$ADMIN") ..."
	ADMIN_HOME=$(eval echo "~$ADMIN")
	if [[ ! -r $ADMIN_HOME ]]; then caterr <<-EOF; return 1; fi
		$(bold "ERROR:") The admin's home directory $(bold "$ADMIN_HOME") is not readable.

	EOF
	ADMIN_CFG="$(cfgfile $ADMIN_HOME)"
	readcfg "$ADMIN_CFG"
	if (( $? )); then echo; return 1; fi
	echo
	writecfg
	return 0
}

admin-install () {
	echo "-------------------------------------------------------------------------------"
	echo "                  CS:GO Multi Server Manager - Admin Install"
	echo "-------------------------------------------------------------------------------"
	echo
	echo "Checking for an existing configuration ..."
	if readcfg 2> /dev/null; then
		if [[ $ADMIN == $USER ]]; then
			catwarn <<-EOF
				$(bold "WARN:")  A valid admin configuration already exists for this user $(bold "$ADMIN").
				       If you continue, the installation steps will be executed again.

			EOF
		else
			catwarn <<-EOF
				$(bold "WARN:")  This user is currently configured as client of user $(bold "$ADMIN").
				       If you continue, this user will create an own game installation instead.

			EOF
		fi
		if ! prompt; then echo; return 1; fi
	fi
	if [[ ! "$APPNAME" || ! "$APPID" ]]; then caterr <<-EOF; return 1; fi
		$(bold "ERROR:") APPNAME and APPID are not set! Check this script and your configuration
		       file and try again!"
		EOF
	echo
	ADMIN="$USER"
	ADMIN_HOME=~
	echo "You started the admin Installation for user $(bold "$ADMIN")"
	echo "This will create a configuration file in the location:"
	echo "        $(bold "$CFG")"
	echo
	if ! prompt; then echo; return 1; fi
	echo

	############ STEAMCMD ############
	# Check for an existing SteamCMD
	if [[ -x $ADMIN_HOME/steamcmd/steamcmd.sh ]]; then
		STEAMCMD_DIR="$ADMIN_HOME/steamcmd"
		catinfo <<< "$(bold "INFO:")  An existing SteamCMD was found in $(bold "$STEAMCMD_DIR")."
	else
		# Ask for the SteamCMD directory
		echo "To download/update the game, installing SteamCMD is required. Be aware that"
		echo "this will use a lot of data! Please specify the place for SteamCMD to be"
		echo "installed in (absolute or relative to your home directory)."
		echo
		read -r -p "SteamCMD install directory (default: steamcmd) " STEAMCMD_DIR
		echo
		if [[ ! $STEAMCMD_DIR ]]; then
			STEAMCMD_DIR=steamcmd;
		fi
		if [[ ! $STEAMCMD_DIR =~ ^/ ]]; then
			STEAMCMD_DIR="$ADMIN_HOME/$STEAMCMD_DIR"
		fi
		# Download and install SteamCMD
		WDIR=$(pwd)
		mkdir -p "$STEAMCMD_DIR"
		cd "$STEAMCMD_DIR"
		echo "Downloading SteamCMD ..."
		unset SUCCESS
		until [[ $SUCCESS ]]; do
			wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz
			if (( $? )); then
				caterror <<< "$(bold "ERROR:") SteamCMD Download failed."
				if ! prompt "Retry?"; then echo; return 1; fi
			else
				local SUCCESS=1
			fi
		done
		echo

		echo "Extracting ..."
		tar xzvf steamcmd_linux.tar.gz
		rm steamcmd_linux.tar.gz &> /dev/null
		if [[ ! -x $STEAMCMD_DIR/steamcmd.sh ]]; then
			caterror <<< "$(bold "ERROR:") SteamCMD installation failed."
			echo
			return 1
		fi
		echo
		echo "Updating SteamCMD ..."
		echo "quit" | "$STEAMCMD_DIR/steamcmd.sh"
		echo
		echo "SteamCMD installed successfully."
		cd "$WDIR"
	fi

	############ GAME INSTALL DIRECTORY ############
	echo
	# check for an existing game installation
	if [[ $(cat "$ADMIN_HOME/$APPNAME/msm.d/appid" 2> /dev/null) == "$APPID" ]]; then
		INSTALL_DIR="$ADMIN_HOME/$APPNAME"
		catinfo <<< "$(bold "INFO:")  A previous game installation was found in $(bold "$INSTALL_DIR")."
	else
		echo "Next, please select the directory for the game server to be installed in."
		unset SUCCESS
		until [[ $SUCCESS ]]; do
			echo
			read -r -p "Game Server Installation Directory (default: $APPNAME) " INSTALL_DIR
			if [[ ! $INSTALL_DIR ]]; then 
				INSTALL_DIR="$APPNAME" 
			fi
			if [[ ! $INSTALL_DIR =~ ^/ ]]; then
				INSTALL_DIR="$ADMIN_HOME/$INSTALL_DIR"
			fi

			INSTANCE_DIR="$INSTALL_DIR" check-instance-dir

			if (( $? == 1 )); then
				catwarn <<-EOF
					Do you wish to create a base installation in $(bold "$INSTALL_DIR") anyway?

				EOF
				prompt && SUCCESS=1
			elif (( $? )); then
				caterr <<-EOF
					$(bold "ERROR:") $(bold "$INSTALL_DIR") cannot be used as a base
					       installation directory!
				EOF
			else
				SUCCESS=1
			fi
			if [[ ! $SUCCESS ]]; then
				echo "Please specify a different directory."
			fi
		done
		mkdir -p "$INSTALL_DIR"
	fi

	echo
	echo "Preparing installation directories ..."

	INSTANCE_DIR="$INSTALL_DIR"

	# Create Update Script
	local UPSCRIPT="$STEAMCMD_DIR/update"
	cat > "$UPSCRIPT" <<-EOF
		login anonymous
		force_install_dir "$INSTALL_DIR" 
		app_update $APPID
		quit
	EOF

	# Create Validate Script
	local VALSCRIPT="$STEAMCMD_DIR/validate"
	cat > "$VALSCRIPT" <<-EOF
		login anonymous
		force_install_dir "$INSTALL_DIR" 
		app_update $APPID validate
		quit
	EOF

	############ PREPARE MSM DIRECTORY ############
	# Cleaning existing clients up
	delete-all-tmuxes
	rm -rf "$INSTALL_DIR/msm.d/clients" &>/dev/null

	# Create settings directory within INSTALL_DIR
	mkdir -p "$INSTALL_DIR/msm.d"

	echo "$APPID" > "$INSTALL_DIR/msm.d/appid"
	echo "$APPNAME" > "$INSTALL_DIR/msm.d/appname"
	if [[ ! -e "$INSTALL_DIR/msm.d/server.conf" ]]; then
		cp "$SUBSCRIPT_DIR/server.conf" "$INSTALL_DIR/msm.d/server.conf"
	fi
	mkdir -p "$INSTALL_DIR/msm.d/clients"

	fix-permissions

	# Create Config and make it readable
	echo
	writecfg
	chmod a+r "$CFG"

	echo "Basic Setup Complete!"
	echo
	echo "Do you want to install/update the game right now? If you choose No, you can"
	echo "install the game later using \`$THIS_COMM install' or copy the files manually."
	echo
	if prompt "Install Now?"; then
		echo
		update
		return 0
	fi
	echo
	return 0
}




##################################################################################
############################### PROGRAM STARTS HERE ##############################
##################################################################################

######################### INITIAL CHECKS AND CALCULATIONS ########################

echo # Make some space

# Detect if this has been called via source command
if [[ $0 != ${BASH_SOURCE[0]} ]]; then
	echo "$(bold "INFO:")  This script has been invoked using the \`source' builtin."
	echo
	alias exit="unalias exit; return"
fi

# Check required packages
if [[ ! -x $(which awk)  ]]; then caterr <<< "$(bold "ERROR:") \`awk' is not installed, but required for this script!" ; echo; exit 1; fi
if [[ ! -x $(which tmux) ]]; then caterr <<< "$(bold "ERROR:") \`tmux' is not installed, but required for this script!"; echo; exit 1; fi
if [[ ! -x $(which wget) ]]; then caterr <<< "$(bold "ERROR:") \`wget' is not installed, but required for this script!"; echo; exit 1; fi
if [[ ! -x $(which tar)  ]]; then caterr <<< "$(bold "ERROR:") \`tar' is not installed, but required for this script!" ; echo; exit 1; fi

# Get script filename and directory
basename="$(basename "${BASH_SOURCE[0]}")"
dirname="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ $PATH =~ (^|:)$dirname(:|$) ]]; then THIS_COMM="$basename"; else THIS_COMM="${BASH_SOURCE[0]}"; fi
# Fail-safe, in the case that readlink does not exist on the system.
# THIS_DIR will not be correct though if this script is being called through a symlink
THIS_SCRIPT="$(readlink -f "$dirname/$basename" 2> /dev/null || echo "$dirname/$basename")"
THIS_DIR="$(dirname "$THIS_SCRIPT")"
unset basename dirname

############################## LOOK FOR SUBSCRIPTS ###############################

SUBSCRIPT_DIR="$THIS_DIR/scripts-$APPID"
if [[ ! -d $SUBSCRIPT_DIR ]]; then
	caterr <<-EOF
		$(bold "ERROR:") The subscript directory was not found at
		       $(bold "$SUBSCRIPT_DIR")!

	EOF
	exit 1
fi

if [[ ! -r $SUBSCRIPT_DIR/instance.sh ]]; then
	caterr <<-EOF
		$(bold "ERROR:") Instance creation script was not found at
		       $(bold "$SUBSCRIPT_DIR/instance.sh")!

	EOF
	exit 1
fi

if [[ ! -r $SUBSCRIPT_DIR/permissions.sh ]]; then
	caterr <<-EOF
		$(bold "ERROR:") Permission management script was not found at
		       $(bold "$SUBSCRIPT_DIR/permissions.sh")!

	EOF
	exit 1
fi

if [[ ! -r $SUBSCRIPT_DIR/server.conf ]]; then
	caterr <<-EOF
		$(bold "ERROR:") Default server configuration file was not found at
		       $(bold "$SUBSCRIPT_DIR/server.conf")!

	EOF
	exit 1
fi

############################# LOAD CONFIGURATION FILE ############################

NO_COMMAND=1
readcfg 2> /dev/null && set-instance "$DEFAULT_INSTANCE" || NEED_SETUP=1




##################################################################################
########################### LOOP THROUGH ALL PARAMETERS ##########################
##################################################################################

while [[ $1 ]]; do
	unset NEED_SETUP
	unset NO_COMMAND

	############ BEGIN OUTER CASE ############
	case "$1" in

	( info | about | license | copyright )
		info
		;;

	( help | --help | usage )
		usage
		;;

	( admin-install )
		admin-install || exit 0
		;;

	( * )
		# Read configuration changes and start setup if needed
		readcfg || { echo; setup; } || exit 1

		# Check other cases, but respect preconditions

		############ BEGIN INNER CASE ############
		case "$1" in
		( @* )
			set-instance ${1:1}
			;;

		( launch | start )
			start || exit 1
			;;

		( halt | stop )
			stop || exit 1
			;;

		( restart )
			stop &&	start || exit 1
			;;

		( st | stat | status )
			status
			if (( $? == 0 )); then
				echo "$SERVER_TEXT is RUNNING!"
			elif (( $? == 1 )); then
				echo "$SERVER_TEXT is STOPPED!"
			else exit 1; fi
			echo
			;;

		( console )
			console
			;;

		( up | update | install )
			update || exit 1
			;;

		( create | create-instance )
			create-instance || exit 1
			;;

		( validate | repair )
			update validate || exit 1
			;;

		( * )
			caterr <<< "$(bold "ERROR:") Unrecognized Option: $(bold "$1")."
			echo       "       Try \`$THIS_COMM usage' for a list of available commands."
			echo
			exit 1
			;;
		esac
		############ END INNER CASE ############
		;;
	esac
	############ END OUTER CASE ############
	shift

done

if [[ $NEED_SETUP ]]; then unset NEED_SETUP NO_COMMAND; setup; exit $?; fi

if [[ $NO_COMMAND ]]; then unset NO_COMMAND; usage; exit 1; fi

exit 0
