#! /bin/bash
### BEGIN INIT INFO
# Provides: csgo-server
# Required-Start: $remote_fs $syslog
# Required-Stop: $remote_fs $syslog
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
# Short-Description: CS:GO Multi Server Manager
### END INIT INFO

##################################################################################
#                                                                                #
#  CS:GO Multi Server Manager (MSM)                                              #
#                                                                                #
#  Launch and setup your Counter-Strike : Global Offensive Dedicated Server.     #
#                                                                                #
#  Copyright (C) 2013-2015 Cr@zy <webmaster@crazyws.fr>                          #
#  Copyright (C) 2015      Maximilian Wende <maximilian.wende@gmail.com>         #
#                                                                                #
#  CS:GO Multi-Mode Server Manager is free software; you can                     #
#  redistribute it and/or modify it under the terms of the GNU Lesser General    #
#  Public License as published by the Free Software Foundation, either version 3 #
#  of the License, or (at your option) any later version.                        #
#                                                                                #
#  CS:GO Multi-Mode Server Manager is distributed in the hope                    #
#  that it will be useful, but WITHOUT ANY WARRANTY; without even the implied    #
#  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the      #
#  GNU Lesser General Public License for more details.                           #
#                                                                                #
#  You should have received a copy of the GNU Lesser General Public License      #
#  along with this program. If not, see http://www.gnu.org/licenses/.            #
#                                                                                #
#  Usage: TO BE REWORKED                                                         #
#                                                                                #
##################################################################################

################################## CONFIGURATION #################################

# APPID, APPNAME: Steam App ID an name of the game to be managed
APPID=740
APPNAME="csgo"

# SERVER_EXEC: The executable file of the server, within INSTANCE_DIR
SERVER_EXEC="srcds_run"

# MSM_CFG: General Configuration file location
# if a relative path is given, it is interpreted as relative to the user's home directory
MSM_CFG="$APPNAME-msm.conf"



################################ HELPER FUNCTIONS ################################
# Get absolute config file location, based on MSM_CFG
# $1 is the base directory, if omitted, the current home directory is taken
cfgfile () {
	if [[ $(echo "$MSM_CFG" | grep ^/) ]]; then
		local CFG="$MSM_CFG"
	else
		if [[ $1 ]]; then
			echo "$1/$MSM_CFG"
		else
			echo "$HOME/$MSM_CFG"
		fi
	fi
}

# A yes/no prompt. With the first parameter $1, an alternative prompt message can be given
# By default, a no will exit the program with an exit code of 1. By putting anything as $2,
# the function will instead return with a value of 1.
prompt () {
	PROMPT="Proceed?"
	if [[ $1 ]]; then PROMPT="$1"; fi

	read -r -p "$PROMPT (Y/n) " INPUT

	if [[ $INPUT && $INPUT != y && $INPUT != Y ]]; then 
		if [[ $2 ]]; then return 1; else exit 1; fi
	fi
}

# Sets the instance to the value of $1
set-instance () {
	INSTANCE="$1"
	if [[ $INSTANCE ]];
	then
		INSTANCE_DIR="$HOME/$APPNAME@$INSTANCE"
		SERVER_TEXT="Server Instance @$INSTANCE"
	else
		INSTANCE_DIR="$INSTALL_DIR"
		SERVER_TEXT="Base Installation"
	fi
	SESSION_NAME="$USER@$INSTANCE"
	# Prints usage if no more commands are given
	printusage=1
}



############################## VARIABLE DEFINITIONS ##############################
THIS_COMMAND="$(basename "${BASH_SOURCE[0]}")"
THIS_SCRIPT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$THIS_COMMAND"
CFG=`cfgfile`



############################# TMUX CONTROL FUNCTIONS #############################
delete-tmux () {
	tmux -S "$TMUX_SOCKET" kill-server
	rm $TMUX_SOCKET
	return 0
}

delete-all-tmuxes () {
	local BASEPATH="$INSTALL_DIR/.msm/clients"
	for socket in $(ls "$BASEPATH"); do
		local TMUX_SOCKET="$BASEPATH/$socket"
		if [[ -w $TMUX_SOCKET ]]; then
			delete-tmux
		fi
	done
	unset socket
}



############################ SERVER CONTROL FUNCTIONS ############################
start () {
	echo "Starting $SERVER_TEXT ..."
	# Nothing to do if server is already running
	if status; then
		echo "INFO:  $SERVER_TEXT is already running!"
		echo "       Enter the console using \`$THIS_COMMAND @$INSTANCE console'"
		echo
		return true
	fi

	if [[ ! -d $INSTANCE_DIR ]]; then
		echo "ERROR: Instance directory < $INSTANCE_DIR > does not exist!"
		echo "       Create an instance using \`$THIS_COMMAND @$INSTANCE create-instance'"
		echo
		return false
	fi

	if [[ ! -w $INSTANCE_DIR ]]; then
		echo "ERROR: You do not have write access to < $INSTANCE_DIR > !"
		echo "       Only < $ADMIN > can modify and launch the base installation! Try creating"
		echo "       an own instance using \`$THIS_COMMAND @name create-instance' instead."
		echo
		return false
	fi

	if [[ ! -x $INSTANCE_DIR/$SERVER_EXEC ]]; then
		echo "ERROR: Server Executable not found at < $INSTANCE_DIR/$SERVER_EXEC > !"
		echo "       Try repairing the installation using \`$THIS_COMMAND update',"
		echo "       \`$THIS_COMMAND repair' or rebuild this instance."
		echo
		return false
	fi

	echo
	echo "$SERVER_TEXT started successfully!"
	echo "To enter the game's console, type \`$THIS_COMMAND @$INSTANCE console'."
	echo
	return true
}

stop () {
	echo "Stopping $SERVER_TEXT ..."
	status || { echo; return 0; }

	echo
}

# Status (Up/Down and extra info) of the server in tmux session $SESSION_NAME
status () {
	TMUX_SOCKET="$INSTALL_DIR/.msm/clients/$SESSION_NAME"

	# Check if tmux socket exists and is accessible
	if [[ ! -e "$TMUX_SOCKET" ]]; then
		return false
	fi
	if [[ ! -w "$TMUX_SOCKET" ]]; then
		echo "ERROR: Cannot access socket of session < $SESSION_NAME> !"
		echo
		exit 1
	fi

	if ( tmux -S "$TMUX_SOCKET" has-session >/dev/null ); then
		# No session runs within tmux
		delete-tmux
		return false
	fi

	# Get server pid and owner
	eval "local $(tmux -S "$TMUX_SOCKET" showenv SERVER_PID)"
	local SOCKET_OWNER="$(ls -ld "$TMUX_SOCKET" | awk 'NR==1 {print $3}')"
	if [[ ! $SERVER_PID ]]; then delete-tmux; fi

	# Check, if pid actually is the server and belongs to the user
	local PS_OUT="$(ps -o uname=,comm= -p "$SERVER_PID"  2>/dev/null)"
	if [[ $PS_OUT != "$SOCKET_OWNER $SERVER_EXEC" ]]; then
	then
		delete-tmux
		return false
	fi
	# Game Server found
	return true
}

# Switch to the game console in tmux session
console () {
	status
}



###################### SERVER INSTANCE MANAGEMENT FUNCTIONS ######################
create-instance () {
	echo "-------------------------------------------------------------------------------"
	echo "               CS:GO Multi-Mode Server Manager - Instance Setup"
	echo "-------------------------------------------------------------------------------"
	echo
	echo ""
}



########################### ADMIN MANAGEMENT FUNCTIONS ###########################
update () {
	if [[ $USER != $ADMIN ]]; then
		echo "Only the admin < $ADMIN > can manage and update the game installation."
		echo "Please log in to the account of < $ADMIN > now! (or CTRL-D to cancel)"
		echo
		su - "$ADMIN" -c "\"$THIS_SCRIPT\" update"
		if (( $? )); then
			echo "ERROR: Update as < $ADMIN > failed!"
			echo
			return 1
		fi
		return 0
	fi

	local LOGFILE="$STEAMCMD_DIR/update.log"
	rm "$LOGFILE" &> /dev/null
	echo "Starting Game Update."
	echo "Log File: < $LOGFILE >"
	echo

	tries=1
	try=0
	until [[ $SUCCESS ]] || (( ++try > tries )); do
		echo "Current Time: $(date)" >> "$LOGFILE"
		printf "[%2d/%2d] Trying to update the game using SteamCMD.\n" $try $tries >> "$LOGFILE"
		echo   "-------------------------------------------------" >> "$LOGFILE"
		echo | tee -a "$LOGFILE"
		"$STEAMCMD_DIR/steamcmd.sh" +runscript "$STEAMCMD_DIR/update" >> "$LOGFILE" 2&>1
		echo | tee -a "$LOGFILE"
		if [ "$(grep "Success! App '$APPID' already up to date." "$LOGFILE")" ]; then
			local SUCCESS=1
		fi
	done

	unset try tries
	if [[ $SUCCESS ]]; then
		echo "Update completed successfully!"
		echo
		return 0
	else
		echo "Update failed. For more information, see the log file at"
		echo "               < $LOGFILE >"
		echo
		return 1
	fi
}

# Check environment variables for correctness
# If an argument $1 is given, these variables are checked for that user instead of the current one
checkvars () {
	if [[ $1 ]]; then local USER="$1"; fi
	if [[ ! $ADMIN ]]; then
		echo "ERROR: ADMIN is not defined"
		return 1
	fi
	if [[ $USER == $ADMIN && ( ! $STEAMCMD_DIR || ! -x $STEAMCMD_DIR/steamcmd.sh ) ]]; then
		echo "ERROR: STEAMCMD_DIR is not defined or steamcmd.sh was not found in it"
		return 1
	fi
	if [[ ! $INSTALL_DIR ]]; then
		echo "ERROR: INSTALL_DIR is not defined"
		return 1
	fi
	if [[ ! -r $INSTALL_DIR ]]; then
		echo "ERROR: < $INSTALL_DIR > does not exist or is not readable"
		return 1
	fi
	if [[ $(cat "$INSTALL_DIR/.msm/appid" 2> /dev/null) != $APPID ]]; then
		echo "ERROR: The appid of the installation at < $INSTALL_DIR > does not match"
		return 1
	fi
	return 0
}

readcfg () {
	if [[ $1 ]]; then local CFG="$1"; fi
	if [[ -r $CFG ]]; then
		source "$CFG" # this isn't great, as a config file of a different user can potentially be malicious
		checkvars || {
			echo "ERROR: One or more errors in the configuration file < $CFG >"
			return 1
		}
		return 0
	fi
	return 1
}

printcfg () {
	cat <<-EOF
		#! /bin/bash
		# This is a configuration file for CS:GO Multi Server Manager
		ADMIN="$ADMIN"
		INSTALL_DIR="$INSTALL_DIR"
		EOF
	# Vars that are only interesting for the admin
	if [[ $USER == $ADMIN ]]; then cat <<-EOF
		STEAMCMD_DIR="$STEAMCMD_DIR"
		EOF
	fi
}

# Create configuration file for the current user
createcfg () {
	checkvars || exit 1
	CFG=`cfgfile`
	echo "Creating CS:GO MSM Config File in < $CFG >"
	rm $CFG &> /dev/null

	printcfg > $CFG
	echo
}

setup () {
	# First-time setup
	echo "-------------------------------------------------------------------------------"
	echo "                CS:GO Multi-Mode Server Manager - Initial Setup"
	echo "-------------------------------------------------------------------------------"
	echo
	echo "It seems like this is the first time you use this script on this machine."
	echo "Before advancing, be aware of a few things:"
	echo
	echo ">>  A configuration file will be created in the location:"
	echo "               < $CFG >"
	echo
	echo "    If you want to use a different location, exit and edit"
	echo "    the \$MSM_CFG variable within this file accordingly."
	echo
	echo ">>  For multi-user setups, this script must be readable for all users"
	echo "               < $THIS_SCRIPT >"
	echo
	prompt
	# Query steam installation admin user
	echo
	echo "Please choose the user that is responsible for the game installation and"
	echo "updates on this machine. As long as the access rights are correctly set,"
	echo "this server will use the game data provided by that user, which makes"
	echo "re-downloading the game for multiple users unnecessary."
	echo
	while [[ ! $ADMIN_HOME ]]; do
		read -p "Admin's username (default: $USER) " -r ADMIN
		if [[ ! $ADMIN ]]; then ADMIN="$USER"; fi
		if [[ ! $(getent passwd $ADMIN) ]]; then
			echo
			echo "User < $ADMIN > does not exist. Please try again!"
			echo
		fi
		ADMIN_HOME=$(eval echo "~$ADMIN")
		if [[ ! -r $ADMIN_HOME ]]; then
			echo
			echo "That user's home directory < $ADMIN_HOME > is not readable. Please specify a different admin."
			echo
			ADMIN_HOME=
		fi
	done

	echo
	# Check if the admin has a working configuration already
	if [[ $USER != $ADMIN ]]; then
		# If client installation fails (e.g. the admin has no configuration himself,
		# try admin installation
		if ! client-install; then
			echo "Additional installation steps have to be taken on the admin account < $ADMIN >"
			echo "Please log in to the account of < $ADMIN > now!"
			echo
			su - $ADMIN -c "\"$THIS_SCRIPT\" admin-install"
			if (( $? )); then
				echo "ERROR: Admin Installation for < $ADMIN > failed!"
				exit 1
			fi
			# Try client installation again!
			if ! client-install; then
				echo "ERROR: Client Installation failed!"
				exit 1
			fi
		fi
	else
		admin-install
	fi
}

client-install () {
	echo "Trying to import settings from < $ADMIN > ..."
	ADMIN_HOME=$(eval echo "~$ADMIN")
	if [[ ! -r $ADMIN_HOME ]]; then
		echo "ERROR: The admin's home directory < $ADMIN_HOME > is not readable."
		echo
		return 1
	fi
	ADMIN_CFG="$(cfgfile $ADMIN_HOME)"
	readcfg "$ADMIN_CFG"
	if (( $? )); then echo; return 1; fi
	echo
	createcfg
	return 0
}

admin-install () {
	echo "-------------------------------------------------------------------------------"
	echo "                  CS:GO Multi Server Manager - Admin Install"
	echo "-------------------------------------------------------------------------------"
	echo
	echo "Checking for an existing configuration ..."
	readcfg
	if (( $? )); then
		if [[ $ADMIN == $USER ]]; then
			echo
			echo "A valid admin configuration already exists for this user < $ADMIN >."
			echo "If you wish to start over, delete the configuration file"
			echo "               < $CFG >"
			echo "and try again."
			echo
			exit
		else
			echo
			echo "This user is currently configured as client of user < $ADMIN >."
			echo "If you continue, this user will create an own installation of the game instead."
			echo
			prompt
		fi
	fi
	if [[ ! "$APPNAME" || ! "$APPID" ]]; then
		echo "ERROR: APPNAME and APPID are not set. Check this script and your configuration"
		echo "       file and try again"
		echo
		exit 1
	fi
	echo
	ADMIN="$USER"
	ADMIN_HOME=~
	echo "You started the admin Installation for user < $ADMIN >"
	echo "This will create a configuration file in the location:"
	echo "               < $CFG >"
	echo
	prompt
	echo
	# Check for an existing SteamCMD
	if [[ -x $ADMIN_HOME/steamcmd/steamcmd.sh ]]; then
		STEAMCMD_DIR="$ADMIN_HOME/steamcmd"
		echo "An existing SteamCMD installation was found in < $STEAMCMD_DIR >"
		echo
	else
		# Ask for the SteamCMD directory
		echo "To download/update the game, installing SteamCMD is required. Be aware that"
		echo "this will use a lot of data! Please specify the place for SteamCMD to be"
		echo "installed in (absolute or relative to your home directory)."
		echo
		read -r -p "SteamCMD install directory (default: steamcmd) " STEAMCMD_DIR
		echo
		if [[ ! $STEAMCMD_DIR ]]; then 
			STEAMCMD_DIR=steamcmd; 
		fi
		if [[ ! $(echo "$STEAMCMD_DIR" | grep ^/) ]]; then
			STEAMCMD_DIR="$ADMIN_HOME/$STEAMCMD_DIR"
		fi
		# Download and install SteamCMD
		WDIR=$(pwd)
		mkdir -p "$STEAMCMD_DIR"
		cd "$STEAMCMD_DIR"
		echo "Downloading SteamCMD ..."
		until [[ $SUCCESS ]]; do
			wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz
			if (( $? )); then
				echo "SteamCMD Download failed."
				prompt "Retry?"
			else
				SUCCESS=1
			fi
		done
		echo "Extracting ..."
		tar xzvf steamcmd_linux.tar.gz
		rm steamcmd_linux.tar.gz &> /dev/null
		if [[ ! -x $STEAMCMD_DIR/steamcmd.sh ]]; then
			echo "ERROR: SteamCMD installation failed."
			exit 1
		fi
		echo "Updating SteamCMD ..."
		echo "quit" | "$STEAMCMD_DIR/steamcmd.sh"
		echo
		echo "SteamCMD installed successfully."
		echo
		cd "$WDIR"
	fi
	# Now, check for game install directory
	if [[ $(cat "$ADMIN_HOME/$APPNAME/.msm/appid" 2> /dev/null) == "$APPID" ]]; then
		INSTALL_DIR="$ADMIN_HOME/$APPNAME"
		echo "A previous game installation was found in < $INSTALL_DIR >"
		echo
	else
		echo "Next, please select the directory for the game server to be installed in"
		read -r -p "Game Server Installation Directory (default: $APPNAME) " INSTALL_DIR
		echo
		if [[ ! $INSTALL_DIR ]]; then 
			INSTALL_DIR="$APPNAME" 
		fi
		if [[ ! $(echo "$INSTALL_DIR" | grep ^/) ]]; then
			INSTALL_DIR="$ADMIN_HOME/$INSTALL_DIR"
		fi
		mkdir -p "$INSTALL_DIR"
	fi

	# Create Update Script
	local UPSCRIPT="$STEAMCMD_DIR/update"
	cat > "$UPSCRIPT" <<-EOF
		login anonymous
		force_install_dir "$INSTALL_DIR" 
		app_update $APPID
		quit
	EOF

	# Create Repair Script
	local REPSCRIPT="$STEAMCMD_DIR/repair"
	cat > "$REPSCRIPT" <<-EOF
		login anonymous
		force_install_dir "$INSTALL_DIR" 
		app_update $APPID validate
		quit
	EOF

	# Cleaning existing clients up
	delete-all-tmuxes
	rm -rf "$INSTALL_DIR/.msm/clients" &>/dev/null

	# Create settings directory within INSTALL_DIR
	mkdir -p "$INSTALL_DIR/.msm"
	# Make game and settings readable for all users
	chmod -R a+r "$INSTALL_DIR"
	# ... but make sure the authtokens stay private
	touch "$INSTALL_DIR/.msm/authtoken"
	chmod o-rwx "$INSTALL_DIR/msm/authtoken"

	# Create other info and clients directory
	echo "$APPID" > "$INSTALL_DIR/.msm/appid"
	echo "$APPNAME" > "$INSTALL_DIR/.msm/appname"
	mkdir -p "$INSTALL_DIR/.msm/clients"
	chmod a+rwx,g+s "$INSTALL_DIR/.msm/clients"

	# Create Config and make it readable
	createcfg
	chmod a+r "$CFG"

	echo "Basic Setup Complete!"
	echo
	echo "Do you want to install/update the game right now? If you choose No, you can"
	echo "install the game later using \`$THIS_COMMAND update' or copy the files manually."
	echo
	prompt "Install Now?" noexit
	if (( $? )); then
		echo
		update
	else
		echo
	fi
	return 0
}

usage () {
  echo "Usage: $THIS_COMMAND [@instance] {start|stop|status|restart|console|update|create}"
  echo "On console, CTRL+D will detach (return) instead of exiting the server."
  echo
}

############################### PROGRAM STARTS HERE ##############################

# Check required packages
PATH=/bin:/usr/bin:/sbin:/usr/sbin
if [[ ! -x $(which awk)  ]]; then echo "ERROR: \`awk' is not installed, but required for this script!";  exit 1; fi
if [[ ! -x $(which tmux) ]]; then echo "ERROR: \`tmux' is not installed, but required for this script!"; exit 1; fi
if [[ ! -x $(which wget) ]]; then echo "ERROR: \`wget' is not installed, but required for this script!"; exit 1; fi
if [[ ! -x $(which tar)  ]]; then echo "ERROR: \`tar' is not installed, but required for this script!";  exit 1; fi

# Make some space
echo

if [[ grep "^-*help" <<< "$1" ]]; then usage; exit 0; fi
if [[ $1 == "admin-install" ]]; then admin-install; shift; if [ ! "$1" ]; then exit 0; fi; fi

# Load config, else start initial setup
readcfg || { setup; exit 0; }

set-instance ""
########################### LOOP THROUGH ALL PARAMETERS ##########################
while [[ $1 ]]; do
	unset printusage
	if [[ grep "^-*help" <<< "$1" ]]; then usage; exit 0; fi

	# Reload possible config changes
	readcfg

	case "$1" in
		@*)
			set-instance ${1:1}
			shift
		;;

		start)
			shift
			start || exit 1
		;;

		stop)
			shift
			stop
		;;

		restart)
			shift
			stop
			start || exit 1
		;;

		status)
			shift
			if status; 
				then echo "$SERVER_TEXT is RUNNING!"; echo
				else echo "$SERVER_TEXT is STOPPED!"; echo
			fi
		;;

		console)
			shift
			console
		;;

		update)
			shift
			update
		;;

		*)
			echo "ERROR: Unrecognized Option: $1"
			echo
			usage
			exit 1
		;;
	esac
done

if [[ $printusage ]]; then unset printusage; usage; exit 1; fi

exit 0

